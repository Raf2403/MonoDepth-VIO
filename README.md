# Фильтр Калмана в OPENVINS

Так как нам нужно изменить то, как **камера корректирует ошибки** (математика самого MSCKF, работа с фичами, невязки, обновление состояния по картинке), то нам нужно отредактировать файл :

> `/home/simns/ros2_ws/src/open_vins/ov_msckf/src/update/UpdaterMSCKF.cpp`

В этом файле происходит вычисление невязок (residuals) и обновление состояния. В оригинале используется фиксированная ковариация шума измерения (
`sigma_pix`), которую мы задаем в конфиге.

**Что мы делаем:**

1. Найдем место, где формируется матрица ковариации измерений `R` (или `S`).
2. Добавим туда логику **динамического взвешивания** (например, на основе Chi-squared теста или переданной информации о "качестве" фичи).
3. Это позволит фильтру меньше доверять "плохим" точкам и больше "хорошим".

Мы реализовали динамическое взвешивание остатков фильтра Калмана с интеграцией данных от нейросети (Adaptive MSCKF Update). Для этого нужно заменить два файла в проекте `ros2_ws`.

#### Модификация этапа обновления EKF (`UpdaterMSCKF.cpp`)

Изменена логика обработки невязок (residuals) перед обновлением состояния. Вместо бинарной логики "Keep/Reject" (Chi-squared test) реализована **робастная функция стоимости (Robust Cost Function)** типа Huber.

**Старая логика (Hard Thresholding):**
В оригинале использовался жесткий порог $\chi^2_{thresh}$.

$$
\text{Если } r^T S^{-1} r > \chi^2_{thresh} \implies \text{Удалить измерение}
$$

*Проблема:* При резких движениях или ошибках нейросети полезные, но слегка зашумленные измерения отбрасывались, что приводило к потере трека.

**Новая логика (Dynamic Reweighting):**
Мы применяем масштабирование матрицы информации (Information Matrix) на основе двух факторов: статистической ошибки и внешней неуверенности.

1. **Вычисление веса Хубера ($w_{huber}$):**
Для защиты от выбросов (outliers) используется подход M-estimator. Если ошибка измерения превышает порог, мы не удаляем его, а уменьшаем его вес, чтобы его вклад в ошибку рос линейно, а не квадратично.

$$
w_{huber} = \begin{cases} 
1.0 & \text{если } \chi^2 \le \chi^2_{thresh} \\
\sqrt{\frac{\chi^2_{thresh}}{\chi^2}} & \text{если } \chi^2 > \chi^2_{thresh}
\end{cases}
$$
2. **Интеграция нейросетевой неуверенности ($w_{nn}$):**
Используется поле `nn_uncertainty` из структуры Feature.

$$
w_{nn} = \frac{1}{\text{nn\_uncertainty}}
$$
3. **Применение итогового веса:**
Итоговый вес $W = w_{huber} \cdot w_{nn}$ применяется к линеаризованной системе измерений ($H \Delta x = r$).
В коде это реализовано через прямое масштабирование Якобиана и невязки перед QR-компрессией:

$$
H_{new} = W \cdot H_{old}
$$

$$
r_{new} = W \cdot r_{old}
$$

*Математический смысл:* Это эквивалентно увеличению ковариации шума измерения $R$ для конкретной фичи:

$$
R_{effective} = \frac{R_{nominal}}{W^2}
$$

Если нейросеть говорит, что неуверенность высокая (например, `nn_uncertainty = 2.0`), то эффективная ковариация шума для этой точки увеличивается в 4 раза, и фильтр Калмана "доверяет" ей в 4 раза меньше при обновлении траектории.

**Результат:** Система становится устойчивой к отдельным плохим измерениям глубины, сохраняя плавность траектории даже при наличии шума в предсказаниях нейросети.


#### 1. Обновление структуры `Feature`

Файл: `~/ros2_ws/src/open_vins/ov_core/src/feat/Feature.h`
В этот класс добавлено поле `double nn_uncertainty`, которое будет хранить оценку неуверенности от нейросети.

* **Действие:** Скачайте приложенный `Feature.h` и замените им текущий файл.


#### 2. Обновление ядра фильтра `UpdaterMSCKF`

Файл: `~/ros2_ws/src/open_vins/ov_msckf/src/update/UpdaterMSCKF.cpp`
Реализована логика взвешивания:

* Применяется **Huber Loss** для защиты от выбросов (вместо жесткого удаления).
* Учитывается `nn_uncertainty`: чем выше неуверенность нейросети, тем меньше вес измерения при обновлении состояния.
* **Действие:** Скачайте приложенный `UpdaterMSCKF.cpp` и замените им текущий файл.


#### 3. Сборка

После замены файлов выполните пересборку пакетов:

```bash
cd ~/ros2_ws
colcon build --symlink-install --packages-select ov_core ov_msckf
```

Теперь фильтр готов принимать данные о качестве глубины.

#### Ссылка на презентацию : 

https://docs.google.com/presentation/d/11tEn-E_7vLnMK0NswYpZc9yzKKUmFTI2/edit?usp=sharing&ouid=111385991162754608447&rtpof=true&sd=true